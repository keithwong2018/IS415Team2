---
title: "spatial_point_pattern"
author: "Keith Wong"
date: "10/29/2020"
output: 
  html_document: 
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load Packages
```{r}
packages = c('rgdal', 'sf', 'tmap', 'tidyverse', 'sp', 'rgeos','maptools', 'raster', 'spatstat', 'tmaptools', 'spdep', 'OpenStreetMap')
for (p in packages){
  if (!require(p, character.only = T)){
    install.packages(p)
  }
  library(p, character.only = T)
}
```

```{r}
popdata <- read_csv('data/aspatial/planning-area-subzone-age-group-sex-and-type-of-dwelling-june-2011-2019.csv')
```

```{r}
popdata2019 <- popdata %>%
  filter(year == 2019) %>%
  filter(age_group == "65_to_69" | age_group == "70_to_74" | age_group == '75_to_79' | age_group == '80_to_84' | age_group == '85_to_89' | age_group == '90_and_over') %>%
  group_by(planning_area, subzone, age_group) %>%
  summarise(elderly_count = sum(resident_count)) %>%
  ungroup() %>%
  spread(age_group, elderly_count) %>%
  mutate(`elderly_count` = `65_to_69` + `70_to_74` + `75_to_79` + `80_to_84` + `85_to_89` + `90_and_over`)

popdata2019 <- mutate_at(popdata2019, .vars = c("subzone", "planning_area"), .funs=toupper)
```

```{r}
glimpse(popdata2019)
```

## Eldercare 
```{r}
eldercare_sf <- st_read(dsn='data/geospatial', layer='ELDERCARE')
```

```{r}
eldercare_sf <- eldercare_sf %>%
  mutate(label = "Eldercare centres") 
```

Assign EPSG
```{r}
eldercare_sf <- st_transform(eldercare_sf, 3414)
```

```{r}
st_crs(eldercare_sf)
```

Convert sf to sp
```{r}
eldercare_sp <- as_Spatial(eldercare_sf)
eldercare_spatialpoint <- as(eldercare_sp, "SpatialPoints")
```

## Silver Infocomm
```{r}
infocomm_sf <- st_read(dsn='data/geospatial', layer='SILVERINFOCOMM')
```

```{r}
infocomm_sf <- infocomm_sf %>%
  mutate(label = "Silver Infocomm Junc")
```

Assign EPSG
```{r}
infocomm_sf <- st_transform(infocomm_sf, 3414)
```

```{r}
st_crs(infocomm_sf)
```

Check for validity - data is valid
```{r}
test <- st_is_valid(infocomm_sf)
length(which(test==FALSE))
```

Convert sf to sp
```{r}
infocomm_sp <- as_Spatial(infocomm_sf)
infocomm_spatialpoint <- as(infocomm_sp, "SpatialPoints")
```


## CHAS Clinics
```{r}
chas_sf <- st_read(dsn='data/geospatial/chas-clinics-kml.kml')
```

```{r}
chas_sf <- chas_sf %>%
  mutate(label = "Chas Clinics") %>%
  mutate(capacity = 1)
```

Assign EPSG
```{r}
chas_sf <- st_transform(chas_sf, 3414)
```

```{r}
st_crs(chas_sf)
```

Convert sf to sp
```{r}
chas_sp <- as_Spatial(chas_sf)
chas_spatialpoint <- as(chas_sp, "SpatialPoints")
```


## MP_14 Subzone Data
```{r}
mpsz_sf <- st_read(dsn='data/geospatial', layer='MP14_SUBZONE_WEB_PL')
```

```{r}
mpsz_sf <- mpsz_sf %>%
  dplyr::select(SUBZONE_N, PLN_AREA_N, REGION_N, X_ADDR, Y_ADDR, SHAPE_Leng, SHAPE_Area, geometry)
```

Assign EPSG
```{r}
mpsz_sf <- st_transform(mpsz_sf, 3414)
```

```{r}
st_crs(mpsz_sf)
```

```{r}
centroids <- st_centroid(mpsz_sf)
```

Convert sf to sp
```{r}
mpsz_sp <- as_Spatial(mpsz_sf)
```


## Coastal outline
```{r}
sg <- readOGR(dsn = "data/geospatial", layer="CostalOutline")
```

```{r}
sg_osm <- read_osm(mpsz_sp, ext=1.3)
```

```{r}
tm_shape(sg_osm)+ 
  tm_layout(legend.outside = TRUE)+
  tm_rgb()+
tm_shape(sg)+
  tm_borders(alpha=0.5, col = "black", lwd = 1)+
tm_shape(chas_sp)+
  tm_dots(col = "label",
          title="",
          alpha=0.7,
          size = 0.1,
          border.col = "black",
          border.lwd = 5,
          palette=c("red"))+
  tm_shape(eldercare_sp)+
  tm_dots(col = "label",
          title="",
          alpha=0.7,
          size = 0.1,
          border.col = "black",
          border.lwd = 5,
          palette=c("green"))+
  tm_shape(infocomm_sp)+
  tm_dots(col = "label",
          title="",
          alpha=0.7,
          size = 0.1,
          border.col = "black",
          border.lwd = 5,
          palette=c("blue")) +
    tm_layout("Facility Type",
            title.size = 1,
            legend.text.size = 1,
            legend.title.size = 1)
```

## Spatial point pattern analysis for chas clinics

In order to confirm the spatial patterns for chas clinics, we will have to conduct a hypothesis test for all subzones and chas clinic locations. 

H0 = The distribution of chas clinics are randomly distributed. H1= The distribution of chas clinics are not randomly distributed. 

The null hypothesis will be rejected if p-value is smaller than alpha < 0.001i

converting spatialdata into ppp object format

```{r}
chas_ppp <- as(chas_spatialpoint, "ppp")
```

using jittering to better visualize overlapped data
```{r}
chas_ppp_jit <- rjitter(chas_ppp, retry=TRUE, nsim=1, drop=TRUE)
```

```{r}
chas_ppp = chas_ppp_jit[sg_owin]
```

```{r}
K_chas = Kest(chas_ppp, correction = "Ripley")
```


```{r}
K_chas.csr <- envelope(chas_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(K_chas.csr, . - r ~ r, xlab="d", ylab="K(d)-r")
```

```{r}
getKernelDensityMap <- function(ppp, ppp_str) {
  # Rescale from meters to kilometers
  ppp.km <- rescale(ppp, 1000, "km")

  # Computing kernel density estimation using defining bandwidth manually
  kde_1000 <- density(ppp.km, sigma=1, edge=TRUE, kernel="gaussian")

  # Plot
  #par(mfrow=c(1,2))
  #plot(ppp.km, main=ppp_str)
  #plot(kde_1000)
  
  # Converting KDE output into grid object
  gridded_kde_1000_bw <- as.SpatialGridDataFrame.im(kde_1000)
  
  # Converting grid object into raster
  kde_1000_bw_raster <- raster(gridded_kde_1000_bw)
  
  # Assigning projection systems
  projection(kde_1000_bw_raster) <- crs("+init=EPSG:3414 +datum=WGS84 +units=km")
  
  # Plot kernel density map on openstreetmap
  tm_shape(sg_osm)+ 
    tm_layout(legend.outside = TRUE, title=ppp_str)+
    tm_rgb()+
  tm_shape(mpsz_sp)+
    tm_polygons(alpha = 0, border.col = "blue", border.alpha = 0.5)+
  tm_shape(kde_1000_bw_raster) + 
    tm_raster("v", alpha=0.5,  
          palette = "YlOrRd")
  
}
```

```{r}
getKernelDensityMap(chas_ppp, "Chas Clinics KDE")
```


```{r}
require(mgcv)
boxmap <- function(vnam,df,legtitle=NA,mtitle="Box Map",mult=1.5){
  var <- get.var(vnam,df)
  bb <- boxbreaks(var)
  tm_shape(df) +
    tm_fill(vnam,title=legtitle,breaks=bb,palette="-RdBu",
            labels = c("lower outlier", "< 25%", "25% - 50%", "50% - 75%","> 75%", "upper outlier"))
  tm_borders() +
  tm_layout(title=mtitle, title.position = c("right","bottom"))
}
```

```{r}
boxmap("age_group", popdata2019)
```
